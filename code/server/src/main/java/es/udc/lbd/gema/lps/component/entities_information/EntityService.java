/*% if (feature.T_EntitiesInformation) { %*/
package es.udc.lbd.gema.lps.component.entities_information;

import es.udc.lbd.gema.lps.component.entities_information.custom.EntityJSON;
import es.udc.lbd.gema.lps.component.entities_information.custom.EntityPropertyConstraintJSON;
import es.udc.lbd.gema.lps.component.entities_information.custom.EntityPropertyJSON;
import es.udc.lbd.gema.lps.model.service.exceptions.AppRuntimeException;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import jakarta.persistence.EntityManager;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.metamodel.Attribute;
import jakarta.persistence.metamodel.EntityType;
import jakarta.transaction.Transactional;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.metadata.BeanDescriptor;
import jakarta.validation.metadata.ConstraintDescriptor;
import jakarta.validation.metadata.PropertyDescriptor;

import org.apache.commons.lang3.reflect.FieldUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

@Service
@Transactional
public class EntityService {

    private static final Logger logger = LoggerFactory.getLogger(EntityService.class);

    @PersistenceContext
    EntityManager entityManager;

    public Collection<EntityJSON> getEntities() {
        Collection<EntityJSON> ret = new HashSet<EntityJSON>();

        // For each entity
        for (EntityType<?> entity : entityManager.getMetamodel().getEntities()) {
            if (!isHiddenClass(entity.getJavaType().getName())) {
                ret.add(buildJsonFromEntity(entity));
            }
        }

        return ret;
    }

    public List<String> getEntitiesNames() {
        List<String> names = new ArrayList<String>();

        for (EntityType<?> entity : entityManager.getMetamodel().getEntities()) {
            if (!isHiddenClass(entity.getJavaType().getName())) {
                names.add(entity.getJavaType().getSimpleName());
            }
        }

        return names;
    }

    public EntityJSON getEntity(String entityName) {

      // For each entity
      for (EntityType<?> entity : entityManager.getMetamodel().getEntities()) {
        if (!isHiddenClass(entity.getJavaType().getName())) {
          if (entity.getName().toLowerCase().equals(entityName.toLowerCase())) {
            return buildJsonFromEntity(entity);
          }
        }
      }
      throw new IllegalArgumentException("No entity found for name: " + entityName);
    }

    public Collection<EntityPropertyJSON> getProperties(String entityName) {

        // For each entity
        for (EntityType<?> entity : entityManager.getMetamodel().getEntities()) {
            if (!isHiddenClass(entity.getJavaType().getName())) {
                if (entity.getName().equals(entityName)) {
                    return buildJsonFromProperties(entity.getAttributes());
                }
            }
        }
        throw new IllegalArgumentException("No entity found for name: " + entityName);
    }

    public EntityPropertyJSON getProperty(String entityName, String propertyName) {

        // For each entity
        for (EntityType<?> entity : entityManager.getMetamodel().getEntities()) {
            if (!isHiddenClass(entity.getJavaType().getName())) {
                if (entity.getName().equals(entityName)) {
                    return buildJsonFromProperty(entity.getAttribute(propertyName));
                }
            }
        }
        throw new IllegalArgumentException("No entity found for name: " + entityName);
    }

    // ---- Private methods ----

    private EntityJSON buildJsonFromEntity(EntityType<?> entity) {
        return new EntityJSON(entity.getJavaType().getName(), entity.getName(),
            buildJsonFromProperties(entity.getAttributes()));
    }

    private Set<EntityPropertyJSON> buildJsonFromProperties(Set<?> properties) {
        Set<EntityPropertyJSON> entityProperties = new HashSet<EntityPropertyJSON>();
        for (Object prop : properties) {
            Attribute<?, ?> p = (Attribute<?, ?>) prop;

            entityProperties.add(buildJsonFromProperty(p));
        }
        return entityProperties;
    }

    private EntityPropertyJSON buildJsonFromProperty(Attribute<?, ?> property) {
        List<Field> autogeneratedFields = FieldUtils.getFieldsListWithAnnotation(property.getDeclaringType().getJavaType(), GeneratedValue.class);
        String autogeneratedField = "";
        if (!autogeneratedFields.isEmpty()) {
            autogeneratedField = FieldUtils.getFieldsListWithAnnotation(property.getDeclaringType().getJavaType(), GeneratedValue.class).iterator().next().getName();
        } else if (autogeneratedFields.size() > 1) {
            throw new AppRuntimeException("More than one autogenerated field found in entity " + property.getDeclaringType().getJavaType().getName());
        }

        EntityPropertyJSON json = new EntityPropertyJSON();
        json.setName(property.getName());
        json.setType(property.getJavaType().getCanonicalName());
        json.setSimpleType(property.getJavaType().getSimpleName());
        json.setCollection(Collection.class.isAssignableFrom(property.getJavaType()));
        json.setAutogenerated(autogeneratedField.equals(property.getName()));

        Validator validator = Validation.buildDefaultValidatorFactory().getValidator();
        BeanDescriptor beanDescriptor = validator.getConstraintsForClass(property.getJavaMember().getDeclaringClass());
        PropertyDescriptor propDesc = beanDescriptor.getConstraintsForProperty(property.getName());

        if(propDesc != null){

            List<EntityPropertyConstraintJSON> constraints = new ArrayList<>();

            for (ConstraintDescriptor<?> descriptor : propDesc.getConstraintDescriptors()) {
                EntityPropertyConstraintJSON entityPropertyConstraintJSON = new EntityPropertyConstraintJSON();
                entityPropertyConstraintJSON.setAnnotationType(descriptor.getAnnotation().annotationType().getSimpleName());
                Map<String,Object> attributes = descriptor.getAttributes();
                entityPropertyConstraintJSON.setAttributes(attributes);
                constraints.add(entityPropertyConstraintJSON);
            }

            json.setConstraints(constraints);
        }

        return json;
    }

    /**
     * Checks if the class should be returned
     *
     * @param className Name of the class
     * @return <ul>
     * <li>{@code true} if the class has the annotation {@link EntityInfo} has {@code hidden} property == {@code true}</li>
     * <li>{@code false} if the above condition is not met</li>
     * </ul>
     */
    private boolean isHiddenClass(String className) {
        try {
            Class<?> clazz = Class.forName(className);
            if (clazz.isAnnotationPresent(EntityInfo.class)) {
                // Hidden class
                if (clazz.getAnnotation(EntityInfo.class).hidden()) {
                    return true;
                }
            }
            return false;
        } catch (ClassNotFoundException e) {
            throw new AppRuntimeException(e);
        }
    }
}
/*% } %*/
